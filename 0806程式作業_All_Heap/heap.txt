max_heap的最高三個

創一個vector
將max_heap最高的丟進去 //[0]

然後開始找vector裡最大的
就只有一個[0],所以最大的就是[0],並取出vector
再來,[0]取出後,設定place = 0
並丟入[place*2+1],[place*2+2]兩個數進去vector
// [1],[2]

一樣從vector裡找最大的,如果[1]1比較大
就取出[1],而[1]就是第二大的
再來,[1]取出後,設定place = 1
並丟入[place*2+1],[place*2+2]兩個數進去vector

// [2],[3],[4]
並再一次從vector裡找最大的，即為第三高

以此類推，去尋找從大到小的排列

min_max_heap最高三個
跟第一個有點像
但是因為會一次跳兩層，演算法不同
min_max_heap裡max層最高的是[1],[2]
將兩者丟入vector裡
找vector裡最大的,如果[1]比較大
就取出[1],而[1]就是最大的
再來,[1]取出後,設定place = 1
並丟入[(place*2+1)*2+1], [(place*2+1)*2+2],[(place*2+2)*2+1],[(place*2+2)*2+2]
// [2],[7],[8],[9],[10]

一樣從vector裡找到最大的
取出後再用此演算法丟入，再比較最大的，依序找到前幾項

deap
跟max_heap一樣
不過一開始丟進去的是[2]，因為max樹[2]是最大

